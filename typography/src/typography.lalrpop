use crate::lexer::{Lexer};
use crate::error::{LexicalError};
use crate::location::Location;
use crate::token::Token;
use crate::parse_tree::*;

grammar<'input>(input: &'input str);

pub Typography: TypoGrammar = {
    GrammarUnit+ => TypoGrammar(<>)
};

GrammarUnit: GrammarUnit = {
    SpecDecl => GrammarUnit::SpecDecl(<>),
    OptionsDecl => GrammarUnit::OptionsDecl(<>)
}

SpecDecl: Box<SpecDecl> = {
    <l:@L> "spec" "{" "}" <r:@R> => {
        Box::new(SpecDecl {
            location: Location::new(l, r)
        })
    }
}

OptionsDecl: Box<OptionsDecl> = {
    <l:@L> "options" "{"  "}" <r:@R> => {
        Box::new(OptionsDecl {
            location: Location::new(l, r),
            // properties
        })
    }
}
//
//PropertyDecl: Box<PropertyDecl> = {
//  <l:@L> <r:@R> => {
//}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        ";" => Token::Semicolon,
        "{" => Token::OpenCurlyBrace,
        "}" => Token::CloseCurlyBrace,
        "(" => Token::OpenParenthesis,
        ")" => Token::CloseParenthesis,
        "=" => Token::Assign,
        "->" => Token::ArrowAssign,
        "=>" => Token::Arrow,
        "?" => Token::Question,
        ":" => Token::Colon,
        "+" => Token::Add,
        "-" => Token::Subtract,
        "*" => Token::Mul,
        "/" => Token::Divide,
        "%" => Token::Modulo,
        "!" => Token::Not,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "." => Token::Member,
        "," => Token::Comma,

        "spec" => Token::Spec,
        "options" => Token::Options,
        "typo"  => Token::Typo,
        "default"  => Token::Default,
        "rule"  => Token::Tokenizer,
        "node"  => Token::Node,
        "ast"  => Token::Ast,
        "template"  => Token::Template,
        "impl"  => Token::Impl,
    }
}
